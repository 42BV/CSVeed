<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ParseStateMachine.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">CSVeed</a> &gt; <a href="index.source.html" class="el_package">org.csveed.token</a> &gt; <span class="el_source">ParseStateMachine.java</span></div><h1>ParseStateMachine.java</h1><pre class="source lang-java linenums">package org.csveed.token;

import static org.csveed.token.ParseState.*;

import org.csveed.common.Column;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
* Yep, a state machine. Managing all kinds of booleans to form a pseudo-state doesn't work really well
* whereas a state machine does. The state machine takes one character at a time, checks routes to the new
* state if necessary and holds tokens, which it returns whenever a field-end ('popToken') has been found.
* @author Robert Bor
*/
<span class="fc" id="L15">public class ParseStateMachine {</span>

<span class="fc" id="L17">    private static final Logger LOG = LoggerFactory.getLogger(ParseStateMachine.class);</span>

<span class="fc" id="L19">    private ParseState state = START_OF_LINE;</span>

<span class="fc" id="L21">    private StringBuilder token = new StringBuilder();</span>

    private int charactersRead;

<span class="fc" id="L25">    private SymbolMapping symbolMapping = new SymbolMapping();</span>

<span class="fc" id="L27">    private TokenState tokenState = TokenState.RESET;</span>

<span class="fc" id="L29">    private boolean trim = true;</span>

    private boolean trash;

<span class="fc" id="L33">    private Column currentColumn = new Column();</span>

<span class="fc" id="L35">    private int currentLine = 1;</span>

<span class="fc" id="L37">    private int newLine = currentLine;</span>

    public int getCurrentLine() {
<span class="fc" id="L40">        return this.currentLine;</span>
    }

    public int getCurrentColumn() {
<span class="fc" id="L44">        return this.currentColumn.getColumnIndex();</span>
    }

    public boolean isTrash() {
<span class="fc" id="L48">        return this.trash;</span>
    }

    public String offerSymbol(int symbolCharacter) throws ParseException {

<span class="fc" id="L53">        this.trash = false;</span>

<span class="fc" id="L55">        EncounteredSymbol symbol = symbolMapping.find(symbolCharacter, state);</span>

<span class="fc bfc" id="L57" title="All 2 branches covered.">        if (symbol.isTrash()) {</span>
<span class="fc" id="L58">            this.trash = true;</span>
<span class="fc" id="L59">            return null;</span>
        }

<span class="fc bfc" id="L62" title="All 2 branches covered.">        if (isFinished()) {</span>
<span class="fc" id="L63">            throw new ParseException(state, symbolCharacter, symbol);</span>
        }

<span class="fc bfc" id="L66" title="All 2 branches covered.">        if (currentLine != newLine) {</span>
<span class="fc" id="L67">            state = START_OF_LINE;</span>
<span class="fc" id="L68">            charactersRead = 0;</span>
<span class="fc" id="L69">            currentColumn = currentColumn.nextLine();</span>
<span class="fc" id="L70">            currentLine = newLine;</span>
        }

<span class="fc bfc" id="L73" title="All 2 branches covered.">        if (currentLine &lt; symbolMapping.getStartLine()) {</span>
<span class="fc" id="L74">            state = SKIP_LINE;</span>
        }

<span class="fc bfc" id="L77" title="All 2 branches covered.">        if (tokenState.isStart()) {</span>
<span class="fc" id="L78">            tokenState = tokenState.next();</span>
        }

<span class="fc" id="L81">        ParseState newState = determineState(symbolCharacter, symbol);</span>
<span class="fc" id="L82">        LOG.debug(&quot;{} ({}): {} =&gt; {}&quot;, (char)symbolCharacter, symbol, state, newState);</span>

<span class="fc bfc" id="L84" title="All 2 branches covered.">        if (newState.isTokenize()) {</span>
<span class="fc bfc" id="L85" title="All 2 branches covered.">            if (tokenState.isReset()) {</span>
<span class="fc" id="L86">                trim = newState.trim();</span>
<span class="fc" id="L87">                tokenState = tokenState.next();</span>
            }
<span class="fc" id="L89">            token.append((char)symbolCharacter);</span>
        }
<span class="fc" id="L91">        String returnToken = null;</span>

<span class="fc bfc" id="L93" title="All 2 branches covered.">        if (newState.isPopToken()) {</span>
<span class="fc" id="L94">            returnToken = token.toString();</span>
<span class="fc bfc" id="L95" title="All 2 branches covered.">            if (trim) {</span>
<span class="fc" id="L96">                returnToken = returnToken.trim();</span>
            }
<span class="fc" id="L98">            token = new StringBuilder();</span>
<span class="fc" id="L99">            tokenState = tokenState.next();</span>
<span class="fc" id="L100">            currentColumn = currentColumn.nextColumn();</span>
        }

<span class="fc bfc" id="L103" title="All 2 branches covered.">        if (newState.isLineFinished()) {</span>
<span class="fc" id="L104">            newLine++;</span>
<span class="fc" id="L105">        } else {</span>
<span class="fc" id="L106">            charactersRead++;</span>
        }

<span class="fc" id="L109">        state = newState;</span>

<span class="fc" id="L111">        return returnToken;</span>
    }

    public boolean isTokenStart() {
<span class="fc" id="L115">        return tokenState.isStart();</span>
    }

    public boolean isLineFinished() {
<span class="fc" id="L119">        return state.isLineFinished();</span>
    }

    public boolean isFinished() {
<span class="fc bfc" id="L123" title="All 2 branches covered.">        return state == FINISHED;</span>
    }

    public boolean ignoreLine() {
<span class="fc bfc" id="L127" title="All 4 branches covered.">        return state.isIgnore() || isEmptyLine();</span>
    }

    public boolean isEmptyLine() {
<span class="fc bfc" id="L131" title="All 2 branches covered.">        return charactersRead == 0;</span>
    }

    protected ParseState determineState(int symbolCharacter, EncounteredSymbol symbol) throws ParseException {

<span class="pc bpc" id="L136" title="1 of 10 branches missed.">        switch (state) {</span>
            case SKIP_LINE:
<span class="pc bpc" id="L138" title="1 of 3 branches missed.">                switch(symbol) {</span>
                    case EOL_SYMBOL:
<span class="fc" id="L140">                        return SKIP_LINE_FINISHED;</span>
                    case END_OF_FILE_SYMBOL:
<span class="nc" id="L142">                        return FINISHED;</span>
                    default:
<span class="fc" id="L144">                        return SKIP_LINE;</span>
                }
            case COMMENT_LINE:
<span class="pc bpc" id="L147" title="1 of 3 branches missed.">                switch(symbol) {</span>
                    case EOL_SYMBOL:
<span class="fc" id="L149">                        return COMMENT_LINE_FINISHED;</span>
                    case END_OF_FILE_SYMBOL:
<span class="nc" id="L151">                        return FINISHED;</span>
                    default:
<span class="fc" id="L153">                        return COMMENT_LINE;</span>
                }
            case START_OF_LINE:
<span class="fc bfc" id="L156" title="All 2 branches covered.">                switch(symbol) {</span>
                    case COMMENT_SYMBOL:
<span class="fc bfc" id="L158" title="All 2 branches covered.">                        if (symbolMapping.isSkipCommentLines()) {</span>
<span class="fc" id="L159">                            return COMMENT_LINE;</span>
                        }
<span class="fc" id="L161">                } // Fallthrough intentional</span>
            case SEPARATOR:
<span class="fc bfc" id="L163" title="All 6 branches covered.">                switch(symbol) {</span>
                    case SPACE_SYMBOL:
<span class="fc" id="L165">                        return OUTSIDE_BEFORE_FIELD;</span>
                    case QUOTE_SYMBOL:
<span class="fc" id="L167">                        return FIRST_CHAR_INSIDE_QUOTED_FIELD;</span>
                    case SEPARATOR_SYMBOL :
<span class="fc" id="L169">                        return SEPARATOR;</span>
                    case END_OF_FILE_SYMBOL:
<span class="fc" id="L171">                        return FINISHED;</span>
                    case EOL_SYMBOL :
<span class="fc" id="L173">                        return LINE_FINISHED;</span>
                    default :
<span class="fc" id="L175">                        return INSIDE_FIELD;</span>
                }
            case OUTSIDE_BEFORE_FIELD:
<span class="fc bfc" id="L178" title="All 6 branches covered.">                switch(symbol) {</span>
                    case SPACE_SYMBOL:
<span class="fc" id="L180">                        return OUTSIDE_BEFORE_FIELD;</span>
                    case SEPARATOR_SYMBOL :
<span class="fc" id="L182">                        return SEPARATOR;</span>
                    case END_OF_FILE_SYMBOL:
<span class="fc" id="L184">                        return FINISHED;</span>
                    case EOL_SYMBOL :
<span class="fc" id="L186">                        return LINE_FINISHED;</span>
                    case QUOTE_SYMBOL:
<span class="fc" id="L188">                        return FIRST_CHAR_INSIDE_QUOTED_FIELD;</span>
                    default :
<span class="fc" id="L190">                        return INSIDE_FIELD;</span>
                }
            case OUTSIDE_AFTER_FIELD:
<span class="fc bfc" id="L193" title="All 5 branches covered.">                switch (symbol) {</span>
                    case SPACE_SYMBOL:
<span class="fc" id="L195">                        return OUTSIDE_AFTER_FIELD;</span>
                    case SEPARATOR_SYMBOL :
<span class="fc" id="L197">                        return SEPARATOR;</span>
                    case END_OF_FILE_SYMBOL:
<span class="fc" id="L199">                        return FINISHED;</span>
                    case EOL_SYMBOL :
<span class="fc" id="L201">                        return LINE_FINISHED;</span>
                    default :
<span class="fc" id="L203">                        throw new ParseException(state, symbolCharacter, symbol);</span>
                }
            case INSIDE_FIELD:
<span class="fc bfc" id="L206" title="All 5 branches covered.">                switch (symbol) {</span>
                    case SEPARATOR_SYMBOL :
<span class="fc" id="L208">                        return SEPARATOR;</span>
                    case END_OF_FILE_SYMBOL:
<span class="fc" id="L210">                        return FINISHED;</span>
                    case EOL_SYMBOL :
<span class="fc" id="L212">                        return LINE_FINISHED;</span>
                    case QUOTE_SYMBOL :
<span class="fc" id="L214">                        throw new ParseException(state, symbolCharacter, symbol);</span>
                    default :
<span class="fc" id="L216">                        return INSIDE_FIELD;</span>
                }
            case FIRST_CHAR_INSIDE_QUOTED_FIELD:
            case INSIDE_QUOTED_FIELD:
<span class="fc bfc" id="L220" title="All 4 branches covered.">                switch (symbol) {</span>
                    case QUOTE_SYMBOL :
<span class="fc" id="L222">                        return OUTSIDE_AFTER_FIELD;</span>
                    case ESCAPE_SYMBOL :
<span class="fc" id="L224">                        return ESCAPING;</span>
                    case END_OF_FILE_SYMBOL:
<span class="fc" id="L226">                        throw new ParseException(state, symbolCharacter, symbol);</span>
                    default :
<span class="fc" id="L228">                        return INSIDE_QUOTED_FIELD;</span>
                }
            case ESCAPING:
<span class="fc bfc" id="L231" title="All 2 branches covered.">                if (symbolMapping.isSameCharactersForEscapeAndQuote()) { // This is the default</span>
<span class="fc bfc" id="L232" title="All 6 branches covered.">                    switch (symbol) {</span>
                        case SPACE_SYMBOL:
<span class="fc" id="L234">                            return OUTSIDE_AFTER_FIELD;</span>
                        case QUOTE_SYMBOL :
<span class="fc" id="L236">                            return INSIDE_QUOTED_FIELD;</span>
                        case EOL_SYMBOL: // Needed when quote/escape are the same: ...abc&quot;\n
<span class="fc" id="L238">                            return LINE_FINISHED;</span>
                        case SEPARATOR_SYMBOL : // Needed when quote/escape are the same: ...abc&quot;;
<span class="fc" id="L240">                            return SEPARATOR;</span>
                        case END_OF_FILE_SYMBOL:
<span class="fc" id="L242">                            return FINISHED;</span>
                        default :
<span class="fc" id="L244">                            throw new ParseException(state, symbolCharacter, symbol);</span>
                    }
                }
                // We're lenient -- accept everything
<span class="fc" id="L248">                return INSIDE_QUOTED_FIELD;</span>
            default :
<span class="nc" id="L250">                throw new ParseException(state, symbolCharacter, symbol);</span>
        }
    }

    public void setSymbolMapping(SymbolMapping symbolMapping) {
<span class="fc" id="L255">        this.symbolMapping = symbolMapping;</span>
<span class="fc" id="L256">    }</span>

    public SymbolMapping getSymbolMapping() {
<span class="fc" id="L259">        return this.symbolMapping;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.4.201905082037</span></div></body></html>